#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def getStatus(self):
    pass

  def getColumnFamilyMetric(self, keySpace, colFamily):
    """
    Parameters:
     - keySpace
     - colFamily
    """
    pass

  def incrementalBackup(self, keySpace):
    """
    Parameters:
     - keySpace
    """
    pass

  def incrementalBackup2(self, keySpace):
    """
    Parameters:
     - keySpace
    """
    pass

  def snapshotBackup(self, keySpace):
    """
    Parameters:
     - keySpace
    """
    pass

  def snapshotBackup2(self, keySpace):
    """
    Parameters:
     - keySpace
    """
    pass

  def commitLogBackup(self):
    pass

  def commitLogBackup2(self):
    pass

  def restoreBackup(self, keySpace, snapShotName, hostId):
    """
    Parameters:
     - keySpace
     - snapShotName
     - hostId
    """
    pass

  def csvToSsTableConv(self, csvFilePath, keySpace, colFamily, partitioner):
    """
    Parameters:
     - csvFilePath
     - keySpace
     - colFamily
     - partitioner
    """
    pass

  def ssTableImport(self, ssTableFilePath, keySpace, colFamily):
    """
    Parameters:
     - ssTableFilePath
     - keySpace
     - colFamily
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def getStatus(self):
    self.send_getStatus()
    return self.recv_getStatus()

  def send_getStatus(self):
    self._oprot.writeMessageBegin('getStatus', TMessageType.CALL, self._seqid)
    args = getStatus_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getStatus(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getStatus_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getStatus failed: unknown result");

  def getColumnFamilyMetric(self, keySpace, colFamily):
    """
    Parameters:
     - keySpace
     - colFamily
    """
    self.send_getColumnFamilyMetric(keySpace, colFamily)
    return self.recv_getColumnFamilyMetric()

  def send_getColumnFamilyMetric(self, keySpace, colFamily):
    self._oprot.writeMessageBegin('getColumnFamilyMetric', TMessageType.CALL, self._seqid)
    args = getColumnFamilyMetric_args()
    args.keySpace = keySpace
    args.colFamily = colFamily
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getColumnFamilyMetric(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getColumnFamilyMetric_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getColumnFamilyMetric failed: unknown result");

  def incrementalBackup(self, keySpace):
    """
    Parameters:
     - keySpace
    """
    self.send_incrementalBackup(keySpace)
    return self.recv_incrementalBackup()

  def send_incrementalBackup(self, keySpace):
    self._oprot.writeMessageBegin('incrementalBackup', TMessageType.CALL, self._seqid)
    args = incrementalBackup_args()
    args.keySpace = keySpace
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_incrementalBackup(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = incrementalBackup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ea is not None:
      raise result.ea
    raise TApplicationException(TApplicationException.MISSING_RESULT, "incrementalBackup failed: unknown result");

  def incrementalBackup2(self, keySpace):
    """
    Parameters:
     - keySpace
    """
    self.send_incrementalBackup2(keySpace)
    return self.recv_incrementalBackup2()

  def send_incrementalBackup2(self, keySpace):
    self._oprot.writeMessageBegin('incrementalBackup2', TMessageType.CALL, self._seqid)
    args = incrementalBackup2_args()
    args.keySpace = keySpace
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_incrementalBackup2(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = incrementalBackup2_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ea is not None:
      raise result.ea
    raise TApplicationException(TApplicationException.MISSING_RESULT, "incrementalBackup2 failed: unknown result");

  def snapshotBackup(self, keySpace):
    """
    Parameters:
     - keySpace
    """
    self.send_snapshotBackup(keySpace)
    return self.recv_snapshotBackup()

  def send_snapshotBackup(self, keySpace):
    self._oprot.writeMessageBegin('snapshotBackup', TMessageType.CALL, self._seqid)
    args = snapshotBackup_args()
    args.keySpace = keySpace
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshotBackup(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = snapshotBackup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ea is not None:
      raise result.ea
    raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshotBackup failed: unknown result");

  def snapshotBackup2(self, keySpace):
    """
    Parameters:
     - keySpace
    """
    self.send_snapshotBackup2(keySpace)
    return self.recv_snapshotBackup2()

  def send_snapshotBackup2(self, keySpace):
    self._oprot.writeMessageBegin('snapshotBackup2', TMessageType.CALL, self._seqid)
    args = snapshotBackup2_args()
    args.keySpace = keySpace
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshotBackup2(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = snapshotBackup2_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ea is not None:
      raise result.ea
    raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshotBackup2 failed: unknown result");

  def commitLogBackup(self):
    self.send_commitLogBackup()
    return self.recv_commitLogBackup()

  def send_commitLogBackup(self):
    self._oprot.writeMessageBegin('commitLogBackup', TMessageType.CALL, self._seqid)
    args = commitLogBackup_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_commitLogBackup(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = commitLogBackup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ea is not None:
      raise result.ea
    raise TApplicationException(TApplicationException.MISSING_RESULT, "commitLogBackup failed: unknown result");

  def commitLogBackup2(self):
    self.send_commitLogBackup2()
    return self.recv_commitLogBackup2()

  def send_commitLogBackup2(self):
    self._oprot.writeMessageBegin('commitLogBackup2', TMessageType.CALL, self._seqid)
    args = commitLogBackup2_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_commitLogBackup2(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = commitLogBackup2_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ea is not None:
      raise result.ea
    raise TApplicationException(TApplicationException.MISSING_RESULT, "commitLogBackup2 failed: unknown result");

  def restoreBackup(self, keySpace, snapShotName, hostId):
    """
    Parameters:
     - keySpace
     - snapShotName
     - hostId
    """
    self.send_restoreBackup(keySpace, snapShotName, hostId)
    self.recv_restoreBackup()

  def send_restoreBackup(self, keySpace, snapShotName, hostId):
    self._oprot.writeMessageBegin('restoreBackup', TMessageType.CALL, self._seqid)
    args = restoreBackup_args()
    args.keySpace = keySpace
    args.snapShotName = snapShotName
    args.hostId = hostId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_restoreBackup(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = restoreBackup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ea is not None:
      raise result.ea
    return

  def csvToSsTableConv(self, csvFilePath, keySpace, colFamily, partitioner):
    """
    Parameters:
     - csvFilePath
     - keySpace
     - colFamily
     - partitioner
    """
    self.send_csvToSsTableConv(csvFilePath, keySpace, colFamily, partitioner)
    return self.recv_csvToSsTableConv()

  def send_csvToSsTableConv(self, csvFilePath, keySpace, colFamily, partitioner):
    self._oprot.writeMessageBegin('csvToSsTableConv', TMessageType.CALL, self._seqid)
    args = csvToSsTableConv_args()
    args.csvFilePath = csvFilePath
    args.keySpace = keySpace
    args.colFamily = colFamily
    args.partitioner = partitioner
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_csvToSsTableConv(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = csvToSsTableConv_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ea is not None:
      raise result.ea
    raise TApplicationException(TApplicationException.MISSING_RESULT, "csvToSsTableConv failed: unknown result");

  def ssTableImport(self, ssTableFilePath, keySpace, colFamily):
    """
    Parameters:
     - ssTableFilePath
     - keySpace
     - colFamily
    """
    self.send_ssTableImport(ssTableFilePath, keySpace, colFamily)
    return self.recv_ssTableImport()

  def send_ssTableImport(self, ssTableFilePath, keySpace, colFamily):
    self._oprot.writeMessageBegin('ssTableImport', TMessageType.CALL, self._seqid)
    args = ssTableImport_args()
    args.ssTableFilePath = ssTableFilePath
    args.keySpace = keySpace
    args.colFamily = colFamily
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ssTableImport(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ssTableImport_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ea is not None:
      raise result.ea
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ssTableImport failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["getStatus"] = Processor.process_getStatus
    self._processMap["getColumnFamilyMetric"] = Processor.process_getColumnFamilyMetric
    self._processMap["incrementalBackup"] = Processor.process_incrementalBackup
    self._processMap["incrementalBackup2"] = Processor.process_incrementalBackup2
    self._processMap["snapshotBackup"] = Processor.process_snapshotBackup
    self._processMap["snapshotBackup2"] = Processor.process_snapshotBackup2
    self._processMap["commitLogBackup"] = Processor.process_commitLogBackup
    self._processMap["commitLogBackup2"] = Processor.process_commitLogBackup2
    self._processMap["restoreBackup"] = Processor.process_restoreBackup
    self._processMap["csvToSsTableConv"] = Processor.process_csvToSsTableConv
    self._processMap["ssTableImport"] = Processor.process_ssTableImport

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_getStatus(self, seqid, iprot, oprot):
    args = getStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getStatus_result()
    result.success = self._handler.getStatus()
    oprot.writeMessageBegin("getStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getColumnFamilyMetric(self, seqid, iprot, oprot):
    args = getColumnFamilyMetric_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getColumnFamilyMetric_result()
    result.success = self._handler.getColumnFamilyMetric(args.keySpace, args.colFamily)
    oprot.writeMessageBegin("getColumnFamilyMetric", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_incrementalBackup(self, seqid, iprot, oprot):
    args = incrementalBackup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = incrementalBackup_result()
    try:
      result.success = self._handler.incrementalBackup(args.keySpace)
    except BackupRestoreException, ea:
      result.ea = ea
    oprot.writeMessageBegin("incrementalBackup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_incrementalBackup2(self, seqid, iprot, oprot):
    args = incrementalBackup2_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = incrementalBackup2_result()
    try:
      result.success = self._handler.incrementalBackup2(args.keySpace)
    except BackupRestoreException, ea:
      result.ea = ea
    oprot.writeMessageBegin("incrementalBackup2", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshotBackup(self, seqid, iprot, oprot):
    args = snapshotBackup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshotBackup_result()
    try:
      result.success = self._handler.snapshotBackup(args.keySpace)
    except BackupRestoreException, ea:
      result.ea = ea
    oprot.writeMessageBegin("snapshotBackup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshotBackup2(self, seqid, iprot, oprot):
    args = snapshotBackup2_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshotBackup2_result()
    try:
      result.success = self._handler.snapshotBackup2(args.keySpace)
    except BackupRestoreException, ea:
      result.ea = ea
    oprot.writeMessageBegin("snapshotBackup2", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_commitLogBackup(self, seqid, iprot, oprot):
    args = commitLogBackup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = commitLogBackup_result()
    try:
      result.success = self._handler.commitLogBackup()
    except BackupRestoreException, ea:
      result.ea = ea
    oprot.writeMessageBegin("commitLogBackup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_commitLogBackup2(self, seqid, iprot, oprot):
    args = commitLogBackup2_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = commitLogBackup2_result()
    try:
      result.success = self._handler.commitLogBackup2()
    except BackupRestoreException, ea:
      result.ea = ea
    oprot.writeMessageBegin("commitLogBackup2", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_restoreBackup(self, seqid, iprot, oprot):
    args = restoreBackup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = restoreBackup_result()
    try:
      self._handler.restoreBackup(args.keySpace, args.snapShotName, args.hostId)
    except BackupRestoreException, ea:
      result.ea = ea
    oprot.writeMessageBegin("restoreBackup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_csvToSsTableConv(self, seqid, iprot, oprot):
    args = csvToSsTableConv_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = csvToSsTableConv_result()
    try:
      result.success = self._handler.csvToSsTableConv(args.csvFilePath, args.keySpace, args.colFamily, args.partitioner)
    except BackupRestoreException, ea:
      result.ea = ea
    oprot.writeMessageBegin("csvToSsTableConv", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ssTableImport(self, seqid, iprot, oprot):
    args = ssTableImport_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ssTableImport_result()
    try:
      result.success = self._handler.ssTableImport(args.ssTableFilePath, args.keySpace, args.colFamily)
    except BackupRestoreException, ea:
      result.ea = ea
    oprot.writeMessageBegin("ssTableImport", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class getStatus_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getStatus_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getStatus_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getColumnFamilyMetric_args:
  """
  Attributes:
   - keySpace
   - colFamily
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'keySpace', None, None, ), # 1
    (2, TType.STRING, 'colFamily', None, None, ), # 2
  )

  def __init__(self, keySpace=None, colFamily=None,):
    self.keySpace = keySpace
    self.colFamily = colFamily

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.keySpace = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.colFamily = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getColumnFamilyMetric_args')
    if self.keySpace is not None:
      oprot.writeFieldBegin('keySpace', TType.STRING, 1)
      oprot.writeString(self.keySpace)
      oprot.writeFieldEnd()
    if self.colFamily is not None:
      oprot.writeFieldBegin('colFamily', TType.STRING, 2)
      oprot.writeString(self.colFamily)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getColumnFamilyMetric_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getColumnFamilyMetric_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class incrementalBackup_args:
  """
  Attributes:
   - keySpace
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'keySpace', None, None, ), # 1
  )

  def __init__(self, keySpace=None,):
    self.keySpace = keySpace

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.keySpace = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('incrementalBackup_args')
    if self.keySpace is not None:
      oprot.writeFieldBegin('keySpace', TType.STRING, 1)
      oprot.writeString(self.keySpace)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class incrementalBackup_result:
  """
  Attributes:
   - success
   - ea
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ea', (BackupRestoreException, BackupRestoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ea=None,):
    self.success = success
    self.ea = ea

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ea = BackupRestoreException()
          self.ea.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('incrementalBackup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ea is not None:
      oprot.writeFieldBegin('ea', TType.STRUCT, 1)
      self.ea.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class incrementalBackup2_args:
  """
  Attributes:
   - keySpace
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'keySpace', None, None, ), # 1
  )

  def __init__(self, keySpace=None,):
    self.keySpace = keySpace

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.keySpace = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('incrementalBackup2_args')
    if self.keySpace is not None:
      oprot.writeFieldBegin('keySpace', TType.STRING, 1)
      oprot.writeString(self.keySpace)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class incrementalBackup2_result:
  """
  Attributes:
   - success
   - ea
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ea', (BackupRestoreException, BackupRestoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ea=None,):
    self.success = success
    self.ea = ea

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ea = BackupRestoreException()
          self.ea.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('incrementalBackup2_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ea is not None:
      oprot.writeFieldBegin('ea', TType.STRUCT, 1)
      self.ea.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshotBackup_args:
  """
  Attributes:
   - keySpace
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'keySpace', None, None, ), # 1
  )

  def __init__(self, keySpace=None,):
    self.keySpace = keySpace

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.keySpace = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshotBackup_args')
    if self.keySpace is not None:
      oprot.writeFieldBegin('keySpace', TType.STRING, 1)
      oprot.writeString(self.keySpace)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshotBackup_result:
  """
  Attributes:
   - success
   - ea
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ea', (BackupRestoreException, BackupRestoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ea=None,):
    self.success = success
    self.ea = ea

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ea = BackupRestoreException()
          self.ea.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshotBackup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ea is not None:
      oprot.writeFieldBegin('ea', TType.STRUCT, 1)
      self.ea.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshotBackup2_args:
  """
  Attributes:
   - keySpace
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'keySpace', None, None, ), # 1
  )

  def __init__(self, keySpace=None,):
    self.keySpace = keySpace

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.keySpace = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshotBackup2_args')
    if self.keySpace is not None:
      oprot.writeFieldBegin('keySpace', TType.STRING, 1)
      oprot.writeString(self.keySpace)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshotBackup2_result:
  """
  Attributes:
   - success
   - ea
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ea', (BackupRestoreException, BackupRestoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ea=None,):
    self.success = success
    self.ea = ea

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ea = BackupRestoreException()
          self.ea.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshotBackup2_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ea is not None:
      oprot.writeFieldBegin('ea', TType.STRUCT, 1)
      self.ea.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commitLogBackup_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commitLogBackup_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commitLogBackup_result:
  """
  Attributes:
   - success
   - ea
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ea', (BackupRestoreException, BackupRestoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ea=None,):
    self.success = success
    self.ea = ea

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ea = BackupRestoreException()
          self.ea.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commitLogBackup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ea is not None:
      oprot.writeFieldBegin('ea', TType.STRUCT, 1)
      self.ea.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commitLogBackup2_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commitLogBackup2_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commitLogBackup2_result:
  """
  Attributes:
   - success
   - ea
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ea', (BackupRestoreException, BackupRestoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ea=None,):
    self.success = success
    self.ea = ea

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ea = BackupRestoreException()
          self.ea.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commitLogBackup2_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ea is not None:
      oprot.writeFieldBegin('ea', TType.STRUCT, 1)
      self.ea.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class restoreBackup_args:
  """
  Attributes:
   - keySpace
   - snapShotName
   - hostId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'keySpace', None, None, ), # 1
    (2, TType.STRING, 'snapShotName', None, None, ), # 2
    (3, TType.STRING, 'hostId', None, None, ), # 3
  )

  def __init__(self, keySpace=None, snapShotName=None, hostId=None,):
    self.keySpace = keySpace
    self.snapShotName = snapShotName
    self.hostId = hostId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.keySpace = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.snapShotName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.hostId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('restoreBackup_args')
    if self.keySpace is not None:
      oprot.writeFieldBegin('keySpace', TType.STRING, 1)
      oprot.writeString(self.keySpace)
      oprot.writeFieldEnd()
    if self.snapShotName is not None:
      oprot.writeFieldBegin('snapShotName', TType.STRING, 2)
      oprot.writeString(self.snapShotName)
      oprot.writeFieldEnd()
    if self.hostId is not None:
      oprot.writeFieldBegin('hostId', TType.STRING, 3)
      oprot.writeString(self.hostId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class restoreBackup_result:
  """
  Attributes:
   - ea
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ea', (BackupRestoreException, BackupRestoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, ea=None,):
    self.ea = ea

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ea = BackupRestoreException()
          self.ea.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('restoreBackup_result')
    if self.ea is not None:
      oprot.writeFieldBegin('ea', TType.STRUCT, 1)
      self.ea.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class csvToSsTableConv_args:
  """
  Attributes:
   - csvFilePath
   - keySpace
   - colFamily
   - partitioner
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'csvFilePath', None, None, ), # 1
    (2, TType.STRING, 'keySpace', None, None, ), # 2
    (3, TType.STRING, 'colFamily', None, None, ), # 3
    (4, TType.STRING, 'partitioner', None, None, ), # 4
  )

  def __init__(self, csvFilePath=None, keySpace=None, colFamily=None, partitioner=None,):
    self.csvFilePath = csvFilePath
    self.keySpace = keySpace
    self.colFamily = colFamily
    self.partitioner = partitioner

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.csvFilePath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.keySpace = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.colFamily = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.partitioner = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('csvToSsTableConv_args')
    if self.csvFilePath is not None:
      oprot.writeFieldBegin('csvFilePath', TType.STRING, 1)
      oprot.writeString(self.csvFilePath)
      oprot.writeFieldEnd()
    if self.keySpace is not None:
      oprot.writeFieldBegin('keySpace', TType.STRING, 2)
      oprot.writeString(self.keySpace)
      oprot.writeFieldEnd()
    if self.colFamily is not None:
      oprot.writeFieldBegin('colFamily', TType.STRING, 3)
      oprot.writeString(self.colFamily)
      oprot.writeFieldEnd()
    if self.partitioner is not None:
      oprot.writeFieldBegin('partitioner', TType.STRING, 4)
      oprot.writeString(self.partitioner)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class csvToSsTableConv_result:
  """
  Attributes:
   - success
   - ea
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ea', (BackupRestoreException, BackupRestoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ea=None,):
    self.success = success
    self.ea = ea

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ea = BackupRestoreException()
          self.ea.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('csvToSsTableConv_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ea is not None:
      oprot.writeFieldBegin('ea', TType.STRUCT, 1)
      self.ea.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ssTableImport_args:
  """
  Attributes:
   - ssTableFilePath
   - keySpace
   - colFamily
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ssTableFilePath', None, None, ), # 1
    (2, TType.STRING, 'keySpace', None, None, ), # 2
    (3, TType.STRING, 'colFamily', None, None, ), # 3
  )

  def __init__(self, ssTableFilePath=None, keySpace=None, colFamily=None,):
    self.ssTableFilePath = ssTableFilePath
    self.keySpace = keySpace
    self.colFamily = colFamily

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ssTableFilePath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.keySpace = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.colFamily = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ssTableImport_args')
    if self.ssTableFilePath is not None:
      oprot.writeFieldBegin('ssTableFilePath', TType.STRING, 1)
      oprot.writeString(self.ssTableFilePath)
      oprot.writeFieldEnd()
    if self.keySpace is not None:
      oprot.writeFieldBegin('keySpace', TType.STRING, 2)
      oprot.writeString(self.keySpace)
      oprot.writeFieldEnd()
    if self.colFamily is not None:
      oprot.writeFieldBegin('colFamily', TType.STRING, 3)
      oprot.writeString(self.colFamily)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ssTableImport_result:
  """
  Attributes:
   - success
   - ea
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ea', (BackupRestoreException, BackupRestoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ea=None,):
    self.success = success
    self.ea = ea

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ea = BackupRestoreException()
          self.ea.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ssTableImport_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ea is not None:
      oprot.writeFieldBegin('ea', TType.STRUCT, 1)
      self.ea.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
