/**
 * Generated by Scrooge
 *   version: 3.16.3
 *   rev: b8593c83072d94fc44feaa8d97940b9266d84ed0
 *   built at: 20140806-054445
 */
package com.evidence.techops.cass

import com.twitter.scrooge.{
  TFieldBlob, ThriftService, ThriftStruct, ThriftStructCodec, ThriftStructCodec3, ThriftStructFieldInfo, ThriftUtil}
import java.nio.ByteBuffer
import java.util.Arrays
import org.apache.thrift.protocol._
import org.apache.thrift.transport.TTransport
import org.apache.thrift.TApplicationException
import org.apache.thrift.transport.TMemoryBuffer
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.{
  Builder,
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
trait CassOpsAgent[+MM[_]] extends ThriftService {
  
  def getStatus(): MM[String]
  
  def getColumnFamilyMetric(keySpace: String, colFamily: String): MM[String]
  
  def incrementalBackup(keySpace: String): MM[String]
  
  def snapshotBackup(keySpace: String): MM[String]
  
  def snapshotBackup2(keySpace: String): MM[String]
  
  def commitLogBackup(): MM[String]
  
  def restoreBackup(keySpace: String, snapShotName: String, hostId: String): MM[Unit]
  
  def csvToSsTableConv(csvFilePath: String, keySpace: String, colFamily: String, partitioner: String): MM[String]
  
  def ssTableImport(ssTableFilePath: String, keySpace: String, colFamily: String): MM[Boolean]
}


object CassOpsAgent {
  
  object getStatus$args extends ThriftStructCodec3[getStatus$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("getStatus_args")
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: getStatus$args) {
    }
  
    override def encode(_item: getStatus$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): getStatus$args = {
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new getStatus$args(
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
    ): getStatus$args =
      new getStatus$args(
      )
  
    def unapply(_item: getStatus$args): Boolean = true
  
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class getStatus$args(
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product
    with java.io.Serializable
  {
    import getStatus$args._
      def this(
      ) = this(
        Map.empty
      )
  
  
  
    override def write(_oprot: TProtocol) {
      getStatus$args.validate(this)
      _oprot.writeStructBegin(Struct)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): getStatus$args =
      new getStatus$args(
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[getStatus$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[getStatus$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "getStatus$args"
  }
  
  object getStatus$result extends ThriftStructCodec3[getStatus$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("getStatus_result")
    val SuccessField = new TField("success", TType.STRING, 0)
    val SuccessFieldManifest = implicitly[Manifest[String]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: getStatus$result) {
    }
  
    override def encode(_item: getStatus$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): getStatus$result = {
      var success: Option[String] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRING => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new getStatus$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[String] = None
    ): getStatus$result =
      new getStatus$result(
        success
      )
  
    def unapply(_item: getStatus$result): Option[Option[String]] = Some(_item.success)
  
  
    private def readSuccessValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeSuccessField(success_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: String, _oprot: TProtocol) {
      _oprot.writeString(success_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class getStatus$result(
      val success: Option[String],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[String]]
    with java.io.Serializable
  {
    import getStatus$result._
      def this(
        success: Option[String] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      getStatus$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[String] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): getStatus$result =
      new getStatus$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[getStatus$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[getStatus$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "getStatus$result"
  }
  
  object getColumnFamilyMetric$args extends ThriftStructCodec3[getColumnFamilyMetric$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("getColumnFamilyMetric_args")
    val KeySpaceField = new TField("keySpace", TType.STRING, 1)
    val KeySpaceFieldManifest = implicitly[Manifest[String]]
    val ColFamilyField = new TField("colFamily", TType.STRING, 2)
    val ColFamilyFieldManifest = implicitly[Manifest[String]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        KeySpaceField,
        false,
        KeySpaceFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        ColFamilyField,
        false,
        ColFamilyFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: getColumnFamilyMetric$args) {
    }
  
    override def encode(_item: getColumnFamilyMetric$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): getColumnFamilyMetric$args = {
      var keySpace: String = null
      var colFamily: String = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRING => {
                  keySpace = readKeySpaceValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'keySpace' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 2 =>
              _field.`type` match {
                case TType.STRING => {
                  colFamily = readColFamilyValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'colFamily' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new getColumnFamilyMetric$args(
        keySpace,
        colFamily,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      keySpace: String,
      colFamily: String
    ): getColumnFamilyMetric$args =
      new getColumnFamilyMetric$args(
        keySpace,
        colFamily
      )
  
    def unapply(_item: getColumnFamilyMetric$args): Option[scala.Product2[String, String]] = Some(_item)
  
  
    private def readKeySpaceValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeKeySpaceField(keySpace_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(KeySpaceField)
      writeKeySpaceValue(keySpace_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeKeySpaceValue(keySpace_item: String, _oprot: TProtocol) {
      _oprot.writeString(keySpace_item)
    }
  
    private def readColFamilyValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeColFamilyField(colFamily_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(ColFamilyField)
      writeColFamilyValue(colFamily_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeColFamilyValue(colFamily_item: String, _oprot: TProtocol) {
      _oprot.writeString(colFamily_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class getColumnFamilyMetric$args(
      val keySpace: String,
      val colFamily: String,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product2[String, String]
    with java.io.Serializable
  {
    import getColumnFamilyMetric$args._
      def this(
        keySpace: String,
        colFamily: String
      ) = this(
        keySpace,
        colFamily,
        Map.empty
      )
  
    def _1 = keySpace
    def _2 = colFamily
  
  
    override def write(_oprot: TProtocol) {
      getColumnFamilyMetric$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (keySpace ne null) writeKeySpaceField(keySpace, _oprot)
      if (colFamily ne null) writeColFamilyField(colFamily, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      keySpace: String = this.keySpace,
      colFamily: String = this.colFamily,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): getColumnFamilyMetric$args =
      new getColumnFamilyMetric$args(
        keySpace,
        colFamily,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[getColumnFamilyMetric$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[getColumnFamilyMetric$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.keySpace
      case 1 => this.colFamily
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "getColumnFamilyMetric$args"
  }
  
  object getColumnFamilyMetric$result extends ThriftStructCodec3[getColumnFamilyMetric$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("getColumnFamilyMetric_result")
    val SuccessField = new TField("success", TType.STRING, 0)
    val SuccessFieldManifest = implicitly[Manifest[String]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: getColumnFamilyMetric$result) {
    }
  
    override def encode(_item: getColumnFamilyMetric$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): getColumnFamilyMetric$result = {
      var success: Option[String] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRING => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new getColumnFamilyMetric$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[String] = None
    ): getColumnFamilyMetric$result =
      new getColumnFamilyMetric$result(
        success
      )
  
    def unapply(_item: getColumnFamilyMetric$result): Option[Option[String]] = Some(_item.success)
  
  
    private def readSuccessValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeSuccessField(success_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: String, _oprot: TProtocol) {
      _oprot.writeString(success_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class getColumnFamilyMetric$result(
      val success: Option[String],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[String]]
    with java.io.Serializable
  {
    import getColumnFamilyMetric$result._
      def this(
        success: Option[String] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      getColumnFamilyMetric$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[String] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): getColumnFamilyMetric$result =
      new getColumnFamilyMetric$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[getColumnFamilyMetric$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[getColumnFamilyMetric$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "getColumnFamilyMetric$result"
  }
  
  object incrementalBackup$args extends ThriftStructCodec3[incrementalBackup$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("incrementalBackup_args")
    val KeySpaceField = new TField("keySpace", TType.STRING, 1)
    val KeySpaceFieldManifest = implicitly[Manifest[String]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        KeySpaceField,
        false,
        KeySpaceFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: incrementalBackup$args) {
    }
  
    override def encode(_item: incrementalBackup$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): incrementalBackup$args = {
      var keySpace: String = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRING => {
                  keySpace = readKeySpaceValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'keySpace' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new incrementalBackup$args(
        keySpace,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      keySpace: String
    ): incrementalBackup$args =
      new incrementalBackup$args(
        keySpace
      )
  
    def unapply(_item: incrementalBackup$args): Option[String] = Some(_item.keySpace)
  
  
    private def readKeySpaceValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeKeySpaceField(keySpace_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(KeySpaceField)
      writeKeySpaceValue(keySpace_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeKeySpaceValue(keySpace_item: String, _oprot: TProtocol) {
      _oprot.writeString(keySpace_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class incrementalBackup$args(
      val keySpace: String,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[String]
    with java.io.Serializable
  {
    import incrementalBackup$args._
      def this(
        keySpace: String
      ) = this(
        keySpace,
        Map.empty
      )
  
    def _1 = keySpace
  
  
    override def write(_oprot: TProtocol) {
      incrementalBackup$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (keySpace ne null) writeKeySpaceField(keySpace, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      keySpace: String = this.keySpace,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): incrementalBackup$args =
      new incrementalBackup$args(
        keySpace,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[incrementalBackup$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[incrementalBackup$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.keySpace
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "incrementalBackup$args"
  }
  
  object incrementalBackup$result extends ThriftStructCodec3[incrementalBackup$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("incrementalBackup_result")
    val SuccessField = new TField("success", TType.STRING, 0)
    val SuccessFieldManifest = implicitly[Manifest[String]]
    val EaField = new TField("ea", TType.STRUCT, 1)
    val EaFieldManifest = implicitly[Manifest[BackupRestoreException]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        EaField,
        true,
        EaFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: incrementalBackup$result) {
    }
  
    override def encode(_item: incrementalBackup$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): incrementalBackup$result = {
      var success: Option[String] = None
      var ea: Option[BackupRestoreException] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRING => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 1 =>
              _field.`type` match {
                case TType.STRUCT => {
                  ea = Some(readEaValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'ea' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new incrementalBackup$result(
        success,
        ea,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[String] = None,
      ea: Option[BackupRestoreException] = None
    ): incrementalBackup$result =
      new incrementalBackup$result(
        success,
        ea
      )
  
    def unapply(_item: incrementalBackup$result): Option[scala.Product2[Option[String], Option[BackupRestoreException]]] = Some(_item)
  
  
    private def readSuccessValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeSuccessField(success_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: String, _oprot: TProtocol) {
      _oprot.writeString(success_item)
    }
  
    private def readEaValue(_iprot: TProtocol): BackupRestoreException = {
      BackupRestoreException.decode(_iprot)
    }
  
    private def writeEaField(ea_item: BackupRestoreException, _oprot: TProtocol) {
      _oprot.writeFieldBegin(EaField)
      writeEaValue(ea_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeEaValue(ea_item: BackupRestoreException, _oprot: TProtocol) {
      ea_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class incrementalBackup$result(
      val success: Option[String],
      val ea: Option[BackupRestoreException],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product2[Option[String], Option[BackupRestoreException]]
    with java.io.Serializable
  {
    import incrementalBackup$result._
      def this(
        success: Option[String] = None,
        ea: Option[BackupRestoreException] = None
      ) = this(
        success,
        ea,
        Map.empty
      )
  
    def _1 = success
    def _2 = ea
  
  
    override def write(_oprot: TProtocol) {
      incrementalBackup$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      if (ea.isDefined) writeEaField(ea.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[String] = this.success,
      ea: Option[BackupRestoreException] = this.ea,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): incrementalBackup$result =
      new incrementalBackup$result(
        success,
        ea,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[incrementalBackup$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[incrementalBackup$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case 1 => this.ea
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "incrementalBackup$result"
  }
  
  object snapshotBackup$args extends ThriftStructCodec3[snapshotBackup$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("snapshotBackup_args")
    val KeySpaceField = new TField("keySpace", TType.STRING, 1)
    val KeySpaceFieldManifest = implicitly[Manifest[String]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        KeySpaceField,
        false,
        KeySpaceFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: snapshotBackup$args) {
    }
  
    override def encode(_item: snapshotBackup$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): snapshotBackup$args = {
      var keySpace: String = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRING => {
                  keySpace = readKeySpaceValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'keySpace' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new snapshotBackup$args(
        keySpace,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      keySpace: String
    ): snapshotBackup$args =
      new snapshotBackup$args(
        keySpace
      )
  
    def unapply(_item: snapshotBackup$args): Option[String] = Some(_item.keySpace)
  
  
    private def readKeySpaceValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeKeySpaceField(keySpace_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(KeySpaceField)
      writeKeySpaceValue(keySpace_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeKeySpaceValue(keySpace_item: String, _oprot: TProtocol) {
      _oprot.writeString(keySpace_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class snapshotBackup$args(
      val keySpace: String,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[String]
    with java.io.Serializable
  {
    import snapshotBackup$args._
      def this(
        keySpace: String
      ) = this(
        keySpace,
        Map.empty
      )
  
    def _1 = keySpace
  
  
    override def write(_oprot: TProtocol) {
      snapshotBackup$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (keySpace ne null) writeKeySpaceField(keySpace, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      keySpace: String = this.keySpace,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): snapshotBackup$args =
      new snapshotBackup$args(
        keySpace,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[snapshotBackup$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[snapshotBackup$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.keySpace
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "snapshotBackup$args"
  }
  
  object snapshotBackup$result extends ThriftStructCodec3[snapshotBackup$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("snapshotBackup_result")
    val SuccessField = new TField("success", TType.STRING, 0)
    val SuccessFieldManifest = implicitly[Manifest[String]]
    val EaField = new TField("ea", TType.STRUCT, 1)
    val EaFieldManifest = implicitly[Manifest[BackupRestoreException]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        EaField,
        true,
        EaFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: snapshotBackup$result) {
    }
  
    override def encode(_item: snapshotBackup$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): snapshotBackup$result = {
      var success: Option[String] = None
      var ea: Option[BackupRestoreException] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRING => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 1 =>
              _field.`type` match {
                case TType.STRUCT => {
                  ea = Some(readEaValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'ea' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new snapshotBackup$result(
        success,
        ea,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[String] = None,
      ea: Option[BackupRestoreException] = None
    ): snapshotBackup$result =
      new snapshotBackup$result(
        success,
        ea
      )
  
    def unapply(_item: snapshotBackup$result): Option[scala.Product2[Option[String], Option[BackupRestoreException]]] = Some(_item)
  
  
    private def readSuccessValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeSuccessField(success_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: String, _oprot: TProtocol) {
      _oprot.writeString(success_item)
    }
  
    private def readEaValue(_iprot: TProtocol): BackupRestoreException = {
      BackupRestoreException.decode(_iprot)
    }
  
    private def writeEaField(ea_item: BackupRestoreException, _oprot: TProtocol) {
      _oprot.writeFieldBegin(EaField)
      writeEaValue(ea_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeEaValue(ea_item: BackupRestoreException, _oprot: TProtocol) {
      ea_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class snapshotBackup$result(
      val success: Option[String],
      val ea: Option[BackupRestoreException],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product2[Option[String], Option[BackupRestoreException]]
    with java.io.Serializable
  {
    import snapshotBackup$result._
      def this(
        success: Option[String] = None,
        ea: Option[BackupRestoreException] = None
      ) = this(
        success,
        ea,
        Map.empty
      )
  
    def _1 = success
    def _2 = ea
  
  
    override def write(_oprot: TProtocol) {
      snapshotBackup$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      if (ea.isDefined) writeEaField(ea.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[String] = this.success,
      ea: Option[BackupRestoreException] = this.ea,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): snapshotBackup$result =
      new snapshotBackup$result(
        success,
        ea,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[snapshotBackup$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[snapshotBackup$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case 1 => this.ea
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "snapshotBackup$result"
  }
  
  object snapshotBackup2$args extends ThriftStructCodec3[snapshotBackup2$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("snapshotBackup2_args")
    val KeySpaceField = new TField("keySpace", TType.STRING, 1)
    val KeySpaceFieldManifest = implicitly[Manifest[String]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        KeySpaceField,
        false,
        KeySpaceFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: snapshotBackup2$args) {
    }
  
    override def encode(_item: snapshotBackup2$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): snapshotBackup2$args = {
      var keySpace: String = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRING => {
                  keySpace = readKeySpaceValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'keySpace' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new snapshotBackup2$args(
        keySpace,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      keySpace: String
    ): snapshotBackup2$args =
      new snapshotBackup2$args(
        keySpace
      )
  
    def unapply(_item: snapshotBackup2$args): Option[String] = Some(_item.keySpace)
  
  
    private def readKeySpaceValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeKeySpaceField(keySpace_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(KeySpaceField)
      writeKeySpaceValue(keySpace_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeKeySpaceValue(keySpace_item: String, _oprot: TProtocol) {
      _oprot.writeString(keySpace_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class snapshotBackup2$args(
      val keySpace: String,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[String]
    with java.io.Serializable
  {
    import snapshotBackup2$args._
      def this(
        keySpace: String
      ) = this(
        keySpace,
        Map.empty
      )
  
    def _1 = keySpace
  
  
    override def write(_oprot: TProtocol) {
      snapshotBackup2$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (keySpace ne null) writeKeySpaceField(keySpace, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      keySpace: String = this.keySpace,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): snapshotBackup2$args =
      new snapshotBackup2$args(
        keySpace,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[snapshotBackup2$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[snapshotBackup2$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.keySpace
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "snapshotBackup2$args"
  }
  
  object snapshotBackup2$result extends ThriftStructCodec3[snapshotBackup2$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("snapshotBackup2_result")
    val SuccessField = new TField("success", TType.STRING, 0)
    val SuccessFieldManifest = implicitly[Manifest[String]]
    val EaField = new TField("ea", TType.STRUCT, 1)
    val EaFieldManifest = implicitly[Manifest[BackupRestoreException]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        EaField,
        true,
        EaFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: snapshotBackup2$result) {
    }
  
    override def encode(_item: snapshotBackup2$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): snapshotBackup2$result = {
      var success: Option[String] = None
      var ea: Option[BackupRestoreException] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRING => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 1 =>
              _field.`type` match {
                case TType.STRUCT => {
                  ea = Some(readEaValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'ea' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new snapshotBackup2$result(
        success,
        ea,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[String] = None,
      ea: Option[BackupRestoreException] = None
    ): snapshotBackup2$result =
      new snapshotBackup2$result(
        success,
        ea
      )
  
    def unapply(_item: snapshotBackup2$result): Option[scala.Product2[Option[String], Option[BackupRestoreException]]] = Some(_item)
  
  
    private def readSuccessValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeSuccessField(success_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: String, _oprot: TProtocol) {
      _oprot.writeString(success_item)
    }
  
    private def readEaValue(_iprot: TProtocol): BackupRestoreException = {
      BackupRestoreException.decode(_iprot)
    }
  
    private def writeEaField(ea_item: BackupRestoreException, _oprot: TProtocol) {
      _oprot.writeFieldBegin(EaField)
      writeEaValue(ea_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeEaValue(ea_item: BackupRestoreException, _oprot: TProtocol) {
      ea_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class snapshotBackup2$result(
      val success: Option[String],
      val ea: Option[BackupRestoreException],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product2[Option[String], Option[BackupRestoreException]]
    with java.io.Serializable
  {
    import snapshotBackup2$result._
      def this(
        success: Option[String] = None,
        ea: Option[BackupRestoreException] = None
      ) = this(
        success,
        ea,
        Map.empty
      )
  
    def _1 = success
    def _2 = ea
  
  
    override def write(_oprot: TProtocol) {
      snapshotBackup2$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      if (ea.isDefined) writeEaField(ea.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[String] = this.success,
      ea: Option[BackupRestoreException] = this.ea,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): snapshotBackup2$result =
      new snapshotBackup2$result(
        success,
        ea,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[snapshotBackup2$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[snapshotBackup2$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case 1 => this.ea
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "snapshotBackup2$result"
  }
  
  object commitLogBackup$args extends ThriftStructCodec3[commitLogBackup$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("commitLogBackup_args")
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: commitLogBackup$args) {
    }
  
    override def encode(_item: commitLogBackup$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): commitLogBackup$args = {
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new commitLogBackup$args(
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
    ): commitLogBackup$args =
      new commitLogBackup$args(
      )
  
    def unapply(_item: commitLogBackup$args): Boolean = true
  
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class commitLogBackup$args(
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product
    with java.io.Serializable
  {
    import commitLogBackup$args._
      def this(
      ) = this(
        Map.empty
      )
  
  
  
    override def write(_oprot: TProtocol) {
      commitLogBackup$args.validate(this)
      _oprot.writeStructBegin(Struct)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): commitLogBackup$args =
      new commitLogBackup$args(
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[commitLogBackup$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[commitLogBackup$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "commitLogBackup$args"
  }
  
  object commitLogBackup$result extends ThriftStructCodec3[commitLogBackup$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("commitLogBackup_result")
    val SuccessField = new TField("success", TType.STRING, 0)
    val SuccessFieldManifest = implicitly[Manifest[String]]
    val EaField = new TField("ea", TType.STRUCT, 1)
    val EaFieldManifest = implicitly[Manifest[BackupRestoreException]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        EaField,
        true,
        EaFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: commitLogBackup$result) {
    }
  
    override def encode(_item: commitLogBackup$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): commitLogBackup$result = {
      var success: Option[String] = None
      var ea: Option[BackupRestoreException] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRING => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 1 =>
              _field.`type` match {
                case TType.STRUCT => {
                  ea = Some(readEaValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'ea' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new commitLogBackup$result(
        success,
        ea,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[String] = None,
      ea: Option[BackupRestoreException] = None
    ): commitLogBackup$result =
      new commitLogBackup$result(
        success,
        ea
      )
  
    def unapply(_item: commitLogBackup$result): Option[scala.Product2[Option[String], Option[BackupRestoreException]]] = Some(_item)
  
  
    private def readSuccessValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeSuccessField(success_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: String, _oprot: TProtocol) {
      _oprot.writeString(success_item)
    }
  
    private def readEaValue(_iprot: TProtocol): BackupRestoreException = {
      BackupRestoreException.decode(_iprot)
    }
  
    private def writeEaField(ea_item: BackupRestoreException, _oprot: TProtocol) {
      _oprot.writeFieldBegin(EaField)
      writeEaValue(ea_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeEaValue(ea_item: BackupRestoreException, _oprot: TProtocol) {
      ea_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class commitLogBackup$result(
      val success: Option[String],
      val ea: Option[BackupRestoreException],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product2[Option[String], Option[BackupRestoreException]]
    with java.io.Serializable
  {
    import commitLogBackup$result._
      def this(
        success: Option[String] = None,
        ea: Option[BackupRestoreException] = None
      ) = this(
        success,
        ea,
        Map.empty
      )
  
    def _1 = success
    def _2 = ea
  
  
    override def write(_oprot: TProtocol) {
      commitLogBackup$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      if (ea.isDefined) writeEaField(ea.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[String] = this.success,
      ea: Option[BackupRestoreException] = this.ea,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): commitLogBackup$result =
      new commitLogBackup$result(
        success,
        ea,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[commitLogBackup$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[commitLogBackup$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case 1 => this.ea
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "commitLogBackup$result"
  }
  
  object restoreBackup$args extends ThriftStructCodec3[restoreBackup$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("restoreBackup_args")
    val KeySpaceField = new TField("keySpace", TType.STRING, 1)
    val KeySpaceFieldManifest = implicitly[Manifest[String]]
    val SnapShotNameField = new TField("snapShotName", TType.STRING, 2)
    val SnapShotNameFieldManifest = implicitly[Manifest[String]]
    val HostIdField = new TField("hostId", TType.STRING, 3)
    val HostIdFieldManifest = implicitly[Manifest[String]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        KeySpaceField,
        false,
        KeySpaceFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        SnapShotNameField,
        false,
        SnapShotNameFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        HostIdField,
        false,
        HostIdFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: restoreBackup$args) {
    }
  
    override def encode(_item: restoreBackup$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): restoreBackup$args = {
      var keySpace: String = null
      var snapShotName: String = null
      var hostId: String = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRING => {
                  keySpace = readKeySpaceValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'keySpace' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 2 =>
              _field.`type` match {
                case TType.STRING => {
                  snapShotName = readSnapShotNameValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'snapShotName' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 3 =>
              _field.`type` match {
                case TType.STRING => {
                  hostId = readHostIdValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'hostId' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new restoreBackup$args(
        keySpace,
        snapShotName,
        hostId,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      keySpace: String,
      snapShotName: String,
      hostId: String
    ): restoreBackup$args =
      new restoreBackup$args(
        keySpace,
        snapShotName,
        hostId
      )
  
    def unapply(_item: restoreBackup$args): Option[scala.Product3[String, String, String]] = Some(_item)
  
  
    private def readKeySpaceValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeKeySpaceField(keySpace_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(KeySpaceField)
      writeKeySpaceValue(keySpace_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeKeySpaceValue(keySpace_item: String, _oprot: TProtocol) {
      _oprot.writeString(keySpace_item)
    }
  
    private def readSnapShotNameValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeSnapShotNameField(snapShotName_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SnapShotNameField)
      writeSnapShotNameValue(snapShotName_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSnapShotNameValue(snapShotName_item: String, _oprot: TProtocol) {
      _oprot.writeString(snapShotName_item)
    }
  
    private def readHostIdValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeHostIdField(hostId_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(HostIdField)
      writeHostIdValue(hostId_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeHostIdValue(hostId_item: String, _oprot: TProtocol) {
      _oprot.writeString(hostId_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class restoreBackup$args(
      val keySpace: String,
      val snapShotName: String,
      val hostId: String,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product3[String, String, String]
    with java.io.Serializable
  {
    import restoreBackup$args._
      def this(
        keySpace: String,
        snapShotName: String,
        hostId: String
      ) = this(
        keySpace,
        snapShotName,
        hostId,
        Map.empty
      )
  
    def _1 = keySpace
    def _2 = snapShotName
    def _3 = hostId
  
  
    override def write(_oprot: TProtocol) {
      restoreBackup$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (keySpace ne null) writeKeySpaceField(keySpace, _oprot)
      if (snapShotName ne null) writeSnapShotNameField(snapShotName, _oprot)
      if (hostId ne null) writeHostIdField(hostId, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      keySpace: String = this.keySpace,
      snapShotName: String = this.snapShotName,
      hostId: String = this.hostId,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): restoreBackup$args =
      new restoreBackup$args(
        keySpace,
        snapShotName,
        hostId,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[restoreBackup$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[restoreBackup$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 3
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.keySpace
      case 1 => this.snapShotName
      case 2 => this.hostId
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "restoreBackup$args"
  }
  
  object restoreBackup$result extends ThriftStructCodec3[restoreBackup$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("restoreBackup_result")
    val EaField = new TField("ea", TType.STRUCT, 1)
    val EaFieldManifest = implicitly[Manifest[BackupRestoreException]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        EaField,
        true,
        EaFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: restoreBackup$result) {
    }
  
    override def encode(_item: restoreBackup$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): restoreBackup$result = {
      var ea: Option[BackupRestoreException] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRUCT => {
                  ea = Some(readEaValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'ea' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new restoreBackup$result(
        ea,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      ea: Option[BackupRestoreException] = None
    ): restoreBackup$result =
      new restoreBackup$result(
        ea
      )
  
    def unapply(_item: restoreBackup$result): Option[Option[BackupRestoreException]] = Some(_item.ea)
  
  
    private def readEaValue(_iprot: TProtocol): BackupRestoreException = {
      BackupRestoreException.decode(_iprot)
    }
  
    private def writeEaField(ea_item: BackupRestoreException, _oprot: TProtocol) {
      _oprot.writeFieldBegin(EaField)
      writeEaValue(ea_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeEaValue(ea_item: BackupRestoreException, _oprot: TProtocol) {
      ea_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class restoreBackup$result(
      val ea: Option[BackupRestoreException],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[BackupRestoreException]]
    with java.io.Serializable
  {
    import restoreBackup$result._
      def this(
        ea: Option[BackupRestoreException] = None
      ) = this(
        ea,
        Map.empty
      )
  
    def _1 = ea
  
  
    override def write(_oprot: TProtocol) {
      restoreBackup$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (ea.isDefined) writeEaField(ea.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      ea: Option[BackupRestoreException] = this.ea,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): restoreBackup$result =
      new restoreBackup$result(
        ea,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[restoreBackup$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[restoreBackup$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.ea
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "restoreBackup$result"
  }
  
  object csvToSsTableConv$args extends ThriftStructCodec3[csvToSsTableConv$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("csvToSsTableConv_args")
    val CsvFilePathField = new TField("csvFilePath", TType.STRING, 1)
    val CsvFilePathFieldManifest = implicitly[Manifest[String]]
    val KeySpaceField = new TField("keySpace", TType.STRING, 2)
    val KeySpaceFieldManifest = implicitly[Manifest[String]]
    val ColFamilyField = new TField("colFamily", TType.STRING, 3)
    val ColFamilyFieldManifest = implicitly[Manifest[String]]
    val PartitionerField = new TField("partitioner", TType.STRING, 4)
    val PartitionerFieldManifest = implicitly[Manifest[String]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        CsvFilePathField,
        false,
        CsvFilePathFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        KeySpaceField,
        false,
        KeySpaceFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        ColFamilyField,
        false,
        ColFamilyFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        PartitionerField,
        false,
        PartitionerFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: csvToSsTableConv$args) {
    }
  
    override def encode(_item: csvToSsTableConv$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): csvToSsTableConv$args = {
      var csvFilePath: String = null
      var keySpace: String = null
      var colFamily: String = null
      var partitioner: String = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRING => {
                  csvFilePath = readCsvFilePathValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'csvFilePath' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 2 =>
              _field.`type` match {
                case TType.STRING => {
                  keySpace = readKeySpaceValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'keySpace' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 3 =>
              _field.`type` match {
                case TType.STRING => {
                  colFamily = readColFamilyValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'colFamily' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 4 =>
              _field.`type` match {
                case TType.STRING => {
                  partitioner = readPartitionerValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'partitioner' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new csvToSsTableConv$args(
        csvFilePath,
        keySpace,
        colFamily,
        partitioner,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      csvFilePath: String,
      keySpace: String,
      colFamily: String,
      partitioner: String
    ): csvToSsTableConv$args =
      new csvToSsTableConv$args(
        csvFilePath,
        keySpace,
        colFamily,
        partitioner
      )
  
    def unapply(_item: csvToSsTableConv$args): Option[scala.Product4[String, String, String, String]] = Some(_item)
  
  
    private def readCsvFilePathValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeCsvFilePathField(csvFilePath_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(CsvFilePathField)
      writeCsvFilePathValue(csvFilePath_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeCsvFilePathValue(csvFilePath_item: String, _oprot: TProtocol) {
      _oprot.writeString(csvFilePath_item)
    }
  
    private def readKeySpaceValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeKeySpaceField(keySpace_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(KeySpaceField)
      writeKeySpaceValue(keySpace_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeKeySpaceValue(keySpace_item: String, _oprot: TProtocol) {
      _oprot.writeString(keySpace_item)
    }
  
    private def readColFamilyValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeColFamilyField(colFamily_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(ColFamilyField)
      writeColFamilyValue(colFamily_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeColFamilyValue(colFamily_item: String, _oprot: TProtocol) {
      _oprot.writeString(colFamily_item)
    }
  
    private def readPartitionerValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writePartitionerField(partitioner_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(PartitionerField)
      writePartitionerValue(partitioner_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writePartitionerValue(partitioner_item: String, _oprot: TProtocol) {
      _oprot.writeString(partitioner_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class csvToSsTableConv$args(
      val csvFilePath: String,
      val keySpace: String,
      val colFamily: String,
      val partitioner: String,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product4[String, String, String, String]
    with java.io.Serializable
  {
    import csvToSsTableConv$args._
      def this(
        csvFilePath: String,
        keySpace: String,
        colFamily: String,
        partitioner: String
      ) = this(
        csvFilePath,
        keySpace,
        colFamily,
        partitioner,
        Map.empty
      )
  
    def _1 = csvFilePath
    def _2 = keySpace
    def _3 = colFamily
    def _4 = partitioner
  
  
    override def write(_oprot: TProtocol) {
      csvToSsTableConv$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (csvFilePath ne null) writeCsvFilePathField(csvFilePath, _oprot)
      if (keySpace ne null) writeKeySpaceField(keySpace, _oprot)
      if (colFamily ne null) writeColFamilyField(colFamily, _oprot)
      if (partitioner ne null) writePartitionerField(partitioner, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      csvFilePath: String = this.csvFilePath,
      keySpace: String = this.keySpace,
      colFamily: String = this.colFamily,
      partitioner: String = this.partitioner,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): csvToSsTableConv$args =
      new csvToSsTableConv$args(
        csvFilePath,
        keySpace,
        colFamily,
        partitioner,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[csvToSsTableConv$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[csvToSsTableConv$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 4
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.csvFilePath
      case 1 => this.keySpace
      case 2 => this.colFamily
      case 3 => this.partitioner
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "csvToSsTableConv$args"
  }
  
  object csvToSsTableConv$result extends ThriftStructCodec3[csvToSsTableConv$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("csvToSsTableConv_result")
    val SuccessField = new TField("success", TType.STRING, 0)
    val SuccessFieldManifest = implicitly[Manifest[String]]
    val EaField = new TField("ea", TType.STRUCT, 1)
    val EaFieldManifest = implicitly[Manifest[BackupRestoreException]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        EaField,
        true,
        EaFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: csvToSsTableConv$result) {
    }
  
    override def encode(_item: csvToSsTableConv$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): csvToSsTableConv$result = {
      var success: Option[String] = None
      var ea: Option[BackupRestoreException] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRING => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 1 =>
              _field.`type` match {
                case TType.STRUCT => {
                  ea = Some(readEaValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'ea' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new csvToSsTableConv$result(
        success,
        ea,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[String] = None,
      ea: Option[BackupRestoreException] = None
    ): csvToSsTableConv$result =
      new csvToSsTableConv$result(
        success,
        ea
      )
  
    def unapply(_item: csvToSsTableConv$result): Option[scala.Product2[Option[String], Option[BackupRestoreException]]] = Some(_item)
  
  
    private def readSuccessValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeSuccessField(success_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: String, _oprot: TProtocol) {
      _oprot.writeString(success_item)
    }
  
    private def readEaValue(_iprot: TProtocol): BackupRestoreException = {
      BackupRestoreException.decode(_iprot)
    }
  
    private def writeEaField(ea_item: BackupRestoreException, _oprot: TProtocol) {
      _oprot.writeFieldBegin(EaField)
      writeEaValue(ea_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeEaValue(ea_item: BackupRestoreException, _oprot: TProtocol) {
      ea_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class csvToSsTableConv$result(
      val success: Option[String],
      val ea: Option[BackupRestoreException],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product2[Option[String], Option[BackupRestoreException]]
    with java.io.Serializable
  {
    import csvToSsTableConv$result._
      def this(
        success: Option[String] = None,
        ea: Option[BackupRestoreException] = None
      ) = this(
        success,
        ea,
        Map.empty
      )
  
    def _1 = success
    def _2 = ea
  
  
    override def write(_oprot: TProtocol) {
      csvToSsTableConv$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      if (ea.isDefined) writeEaField(ea.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[String] = this.success,
      ea: Option[BackupRestoreException] = this.ea,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): csvToSsTableConv$result =
      new csvToSsTableConv$result(
        success,
        ea,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[csvToSsTableConv$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[csvToSsTableConv$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case 1 => this.ea
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "csvToSsTableConv$result"
  }
  
  object ssTableImport$args extends ThriftStructCodec3[ssTableImport$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("ssTableImport_args")
    val SsTableFilePathField = new TField("ssTableFilePath", TType.STRING, 1)
    val SsTableFilePathFieldManifest = implicitly[Manifest[String]]
    val KeySpaceField = new TField("keySpace", TType.STRING, 2)
    val KeySpaceFieldManifest = implicitly[Manifest[String]]
    val ColFamilyField = new TField("colFamily", TType.STRING, 3)
    val ColFamilyFieldManifest = implicitly[Manifest[String]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SsTableFilePathField,
        false,
        SsTableFilePathFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        KeySpaceField,
        false,
        KeySpaceFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        ColFamilyField,
        false,
        ColFamilyFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: ssTableImport$args) {
    }
  
    override def encode(_item: ssTableImport$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): ssTableImport$args = {
      var ssTableFilePath: String = null
      var keySpace: String = null
      var colFamily: String = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRING => {
                  ssTableFilePath = readSsTableFilePathValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'ssTableFilePath' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 2 =>
              _field.`type` match {
                case TType.STRING => {
                  keySpace = readKeySpaceValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'keySpace' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 3 =>
              _field.`type` match {
                case TType.STRING => {
                  colFamily = readColFamilyValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'colFamily' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new ssTableImport$args(
        ssTableFilePath,
        keySpace,
        colFamily,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      ssTableFilePath: String,
      keySpace: String,
      colFamily: String
    ): ssTableImport$args =
      new ssTableImport$args(
        ssTableFilePath,
        keySpace,
        colFamily
      )
  
    def unapply(_item: ssTableImport$args): Option[scala.Product3[String, String, String]] = Some(_item)
  
  
    private def readSsTableFilePathValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeSsTableFilePathField(ssTableFilePath_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SsTableFilePathField)
      writeSsTableFilePathValue(ssTableFilePath_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSsTableFilePathValue(ssTableFilePath_item: String, _oprot: TProtocol) {
      _oprot.writeString(ssTableFilePath_item)
    }
  
    private def readKeySpaceValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeKeySpaceField(keySpace_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(KeySpaceField)
      writeKeySpaceValue(keySpace_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeKeySpaceValue(keySpace_item: String, _oprot: TProtocol) {
      _oprot.writeString(keySpace_item)
    }
  
    private def readColFamilyValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeColFamilyField(colFamily_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(ColFamilyField)
      writeColFamilyValue(colFamily_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeColFamilyValue(colFamily_item: String, _oprot: TProtocol) {
      _oprot.writeString(colFamily_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class ssTableImport$args(
      val ssTableFilePath: String,
      val keySpace: String,
      val colFamily: String,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product3[String, String, String]
    with java.io.Serializable
  {
    import ssTableImport$args._
      def this(
        ssTableFilePath: String,
        keySpace: String,
        colFamily: String
      ) = this(
        ssTableFilePath,
        keySpace,
        colFamily,
        Map.empty
      )
  
    def _1 = ssTableFilePath
    def _2 = keySpace
    def _3 = colFamily
  
  
    override def write(_oprot: TProtocol) {
      ssTableImport$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (ssTableFilePath ne null) writeSsTableFilePathField(ssTableFilePath, _oprot)
      if (keySpace ne null) writeKeySpaceField(keySpace, _oprot)
      if (colFamily ne null) writeColFamilyField(colFamily, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      ssTableFilePath: String = this.ssTableFilePath,
      keySpace: String = this.keySpace,
      colFamily: String = this.colFamily,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): ssTableImport$args =
      new ssTableImport$args(
        ssTableFilePath,
        keySpace,
        colFamily,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[ssTableImport$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[ssTableImport$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 3
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.ssTableFilePath
      case 1 => this.keySpace
      case 2 => this.colFamily
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "ssTableImport$args"
  }
  
  object ssTableImport$result extends ThriftStructCodec3[ssTableImport$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("ssTableImport_result")
    val SuccessField = new TField("success", TType.BOOL, 0)
    val SuccessFieldManifest = implicitly[Manifest[Boolean]]
    val EaField = new TField("ea", TType.STRUCT, 1)
    val EaFieldManifest = implicitly[Manifest[BackupRestoreException]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        EaField,
        true,
        EaFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: ssTableImport$result) {
    }
  
    override def encode(_item: ssTableImport$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): ssTableImport$result = {
      var success: Option[Boolean] = None
      var ea: Option[BackupRestoreException] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.BOOL => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.BOOL
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 1 =>
              _field.`type` match {
                case TType.STRUCT => {
                  ea = Some(readEaValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'ea' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new ssTableImport$result(
        success,
        ea,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[Boolean] = None,
      ea: Option[BackupRestoreException] = None
    ): ssTableImport$result =
      new ssTableImport$result(
        success,
        ea
      )
  
    def unapply(_item: ssTableImport$result): Option[scala.Product2[Option[Boolean], Option[BackupRestoreException]]] = Some(_item)
  
  
    private def readSuccessValue(_iprot: TProtocol): Boolean = {
      _iprot.readBool()
    }
  
    private def writeSuccessField(success_item: Boolean, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol) {
      _oprot.writeBool(success_item)
    }
  
    private def readEaValue(_iprot: TProtocol): BackupRestoreException = {
      BackupRestoreException.decode(_iprot)
    }
  
    private def writeEaField(ea_item: BackupRestoreException, _oprot: TProtocol) {
      _oprot.writeFieldBegin(EaField)
      writeEaValue(ea_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeEaValue(ea_item: BackupRestoreException, _oprot: TProtocol) {
      ea_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class ssTableImport$result(
      val success: Option[Boolean],
      val ea: Option[BackupRestoreException],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product2[Option[Boolean], Option[BackupRestoreException]]
    with java.io.Serializable
  {
    import ssTableImport$result._
      def this(
        success: Option[Boolean] = None,
        ea: Option[BackupRestoreException] = None
      ) = this(
        success,
        ea,
        Map.empty
      )
  
    def _1 = success
    def _2 = ea
  
  
    override def write(_oprot: TProtocol) {
      ssTableImport$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      if (ea.isDefined) writeEaField(ea.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Boolean] = this.success,
      ea: Option[BackupRestoreException] = this.ea,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): ssTableImport$result =
      new ssTableImport$result(
        success,
        ea,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[ssTableImport$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[ssTableImport$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case 1 => this.ea
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "ssTableImport$result"
  }

  import com.twitter.util.Future

  trait FutureIface extends  CassOpsAgent[Future] {
    
    def getStatus(): Future[String]
    
    def getColumnFamilyMetric(keySpace: String, colFamily: String): Future[String]
    
    def incrementalBackup(keySpace: String): Future[String]
    
    def snapshotBackup(keySpace: String): Future[String]
    
    def snapshotBackup2(keySpace: String): Future[String]
    
    def commitLogBackup(): Future[String]
    
    def restoreBackup(keySpace: String, snapShotName: String, hostId: String): Future[Unit]
    
    def csvToSsTableConv(csvFilePath: String, keySpace: String, colFamily: String, partitioner: String): Future[String]
    
    def ssTableImport(ssTableFilePath: String, keySpace: String, colFamily: String): Future[Boolean]
  }

  class FinagledClient(
      service: com.twitter.finagle.Service[com.twitter.finagle.thrift.ThriftClientRequest, Array[Byte]],
      protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
      serviceName: String = "",
      stats: com.twitter.finagle.stats.StatsReceiver = com.twitter.finagle.stats.NullStatsReceiver)
    extends CassOpsAgent$FinagleClient(
      service,
      protocolFactory,
      serviceName,
      stats)
    with FutureIface

  class FinagledService(
      iface: FutureIface,
      protocolFactory: TProtocolFactory)
    extends CassOpsAgent$FinagleService(
      iface,
      protocolFactory)
}